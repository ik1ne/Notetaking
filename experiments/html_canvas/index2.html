<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Monaco Editor with Stylus Canvas Overlay (Fixed)</title>
    <style>
        html, body, #container {
            margin: 0;
            padding: 0;
            height: 100%;
        }

        #container {
            position: relative;
        }

        #editorContainer {
            width: 100%;
            height: 100%;
        }

        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* pointer-events toggled in script */
        }

        #modeSelector {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 2;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px;
        }
    </style>
</head>
<body>
<div id="container">
    <div id="editorContainer"></div>
    <canvas id="overlayCanvas"></canvas>
    <div id="modeSelector">
        Mode:
        <button id="passBtn">Pass</button>
        <button id="drawBtn">Draw</button>
        <button id="scrollBtn">Scroll</button>
    </div>
</div>

<link rel="stylesheet"
      href="https://unpkg.com/monaco-editor@0.39.0/min/vs/editor/editor.main.css">
<script src="https://unpkg.com/monaco-editor@0.39.0/min/vs/loader.js"></script>
<script>
    require.config({paths: {'vs': 'https://unpkg.com/monaco-editor@0.39.0/min/vs'}});
    require(['vs/editor/editor.main'], function () {
        // Create the Monaco editor in #editorContainer.
        const editor = monaco.editor.create(
            document.getElementById('editorContainer'),
            {
                value: Array(1000).fill('function foo() { console.log("Hello World"); }').join('\n'),
                language: 'javascript',
                theme: 'vs-light',
                automaticLayout: true
            }
        );

        // Overlay setup
        const canvas = document.getElementById('overlayCanvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        //
        // --- MOVE THESE BEFORE ANY scheduleRedraw() CALLS ---
        //
        // Flag & scheduler for rAF-based redraw
        let redrawScheduled = false;

        function scheduleRedraw() {
            if (redrawScheduled) return;
            redrawScheduled = true;
            requestAnimationFrame(() => {
                redrawScheduled = false;
                redrawCanvas();
            });
        }

        // Stroke storage
        const strokes = [];
        let currentStroke = null;
        let isDrawing = false;
        let scrollStartY, scrollStartX, origScrollTop, origScrollLeft, pointerId;
        let mode = 'pass'; // 'pass' | 'draw' | 'scroll'

        // Helpers
        function computeBBox(points) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const p of points) {
                if (p.x < minX) minX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.x > maxX) maxX = p.x;
                if (p.y > maxY) maxY = p.y;
            }
            return {minX, minY, maxX, maxY};
        }

        // Resize canvas to match editor container
        function resizeCanvas() {
            const rect = editor.getDomNode().getBoundingClientRect();
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            scheduleRedraw();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Mode buttons
        document.getElementById('passBtn').onclick = () => setMode('pass');
        document.getElementById('drawBtn').onclick = () => setMode('draw');
        document.getElementById('scrollBtn').onclick = () => setMode('scroll');

        function setMode(m) {
            mode = m;
            canvas.style.pointerEvents = m === 'pass' ? 'none' : 'auto';
        }

        setMode('pass');

        // Pointer events
        canvas.addEventListener('pointerdown', e => {
            if (mode === 'draw' && e.pointerType === 'pen') {
                e.preventDefault();
                pointerId = e.pointerId;
                isDrawing = true;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top + editor.getScrollTop();
                currentStroke = {points: [{x, y, p: e.pressure}]};
                ctx.beginPath();
                ctx.moveTo(x, y - editor.getScrollTop());
            } else if (mode === 'scroll') {
                e.preventDefault();
                pointerId = e.pointerId;
                isDrawing = true;
                scrollStartY = e.clientY;
                scrollStartX = e.clientX;
                origScrollTop = editor.getScrollTop();
                origScrollLeft = editor.getScrollLeft();
            }
        });

        canvas.addEventListener('pointermove', e => {
            if (!isDrawing || e.pointerId !== pointerId) return;
            const rect = canvas.getBoundingClientRect();
            if (mode === 'draw') {
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top + editor.getScrollTop();
                currentStroke.points.push({x, y, p: e.pressure});
                ctx.lineWidth = 2 * e.pressure;
                ctx.lineCap = 'round';
                ctx.lineTo(x, y - editor.getScrollTop());
                ctx.stroke();
            } else if (mode === 'scroll') {
                const dy = e.clientY - scrollStartY;
                const dx = e.clientX - scrollStartX;
                editor.setScrollTop(origScrollTop - dy);
                editor.setScrollLeft(origScrollLeft - dx);
                scheduleRedraw();
            }
        });

        canvas.addEventListener('pointerup', e => {
            if (!isDrawing || e.pointerId !== pointerId) return;
            isDrawing = false;
            pointerId = null;
            if (mode === 'draw' && currentStroke) {
                currentStroke.bbox = computeBBox(currentStroke.points);
                strokes.push(currentStroke);
                currentStroke = null;
            }
        });
        canvas.addEventListener('pointercancel', e => {
            canvas.dispatchEvent(new PointerEvent('pointerup', e));
        });

        // Redraw only visible strokes
        function redrawCanvas() {
            const rect = canvas.getBoundingClientRect();
            ctx.clearRect(0, 0, rect.width, rect.height);
            const viewTop = editor.getScrollTop();
            const viewBottom = viewTop + rect.height;
            ctx.save();
            ctx.translate(0, -viewTop);
            ctx.lineCap = 'round';
            for (const stroke of strokes) {
                const bb = stroke.bbox;
                if (!bb || bb.maxY < viewTop || bb.minY > viewBottom) continue;
                ctx.beginPath();
                for (let i = 0; i < stroke.points.length; i++) {
                    const pt = stroke.points[i];
                    if (i === 0) ctx.moveTo(pt.x, pt.y);
                    else {
                        ctx.lineWidth = 2 * pt.p;
                        ctx.lineTo(pt.x, pt.y);
                    }
                }
                ctx.stroke();
            }
            ctx.restore();
        }

        // Also redraw when the editor scrolls by other means
        editor.onDidScrollChange(() => scheduleRedraw());

        // Initial draw
        scheduleRedraw();
    });
</script>
</body>
</html>
