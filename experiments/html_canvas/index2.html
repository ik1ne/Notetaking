<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Monaco Editor with Stylus Canvas Overlay (Point-Level Pressure)</title>
    <style>
        html, body, #container {
            margin: 0;
            padding: 0;
            height: 100%;
        }

        #container {
            position: relative;
        }

        #editorContainer {
            width: 100%;
            height: 100%;
        }

        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #modeSelector {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px;
            z-index: 2;
        }
    </style>
</head>
<body>
<div id="container">
    <div id="editorContainer"></div>
    <canvas id="overlayCanvas"></canvas>
    <div id="modeSelector">
        Mode:
        <button id="passBtn">Pass</button>
        <button id="drawBtn">Draw</button>
        <button id="scrollBtn">Scroll</button>
    </div>
</div>

<link rel="stylesheet" href="https://unpkg.com/monaco-editor@0.39.0/min/vs/editor/editor.main.css">
<script src="https://unpkg.com/monaco-editor@0.39.0/min/vs/loader.js"></script>
<script>
    require.config({paths: {'vs': 'https://unpkg.com/monaco-editor@0.39.0/min/vs'}});
    require(['vs/editor/editor.main'], function () {
        const editor = monaco.editor.create(
            document.getElementById('editorContainer'),
            {
                value: Array(1000).fill('function foo() { console.log("Hello World"); }').join('\n'),
                language: 'javascript',
                theme: 'vs-light',
                minimap: {enabled: false}
            }
        );

        const canvas = document.getElementById('overlayCanvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        // rAF redraw scheduler
        let redrawScheduled = false;

        function scheduleRedraw() {
            if (redrawScheduled) return;
            redrawScheduled = true;
            requestAnimationFrame(() => {
                redrawScheduled = false;
                redrawCanvas();
            });
        }

        // Resize canvas to match editor
        function resizeCanvas() {
            const rect = editor.getDomNode().getBoundingClientRect();
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            scheduleRedraw();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Modes: pass, draw, scroll
        let mode = 'pass';
        document.getElementById('passBtn').onclick = () => setMode('pass');
        document.getElementById('drawBtn').onclick = () => setMode('draw');
        document.getElementById('scrollBtn').onclick = () => setMode('scroll');

        function setMode(m) {
            mode = m;
            canvas.style.pointerEvents = m === 'pass' ? 'none' : 'auto';
            // Redraw strokes after mode change to ensure visibility
            scheduleRedraw();
        }

        setMode('pass');

        // Stroke data: each point holds x,y,pressure
        const strokes = [];
        let currentStroke = null;
        let isDrawing = false;
        let scrollStartY, scrollStartX, origScrollTop, origScrollLeft;

        function computeBBox(points) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const pt of points) {
                if (pt.x < minX) minX = pt.x;
                if (pt.y < minY) minY = pt.y;
                if (pt.x > maxX) maxX = pt.x;
                if (pt.y > maxY) maxY = pt.y;
            }
            return {minX, minY, maxX, maxY};
        }

        // Start stroke on pen down
        canvas.addEventListener('pointerdown', e => {
            if (mode === 'draw' && e.pointerType === 'pen') {
                e.preventDefault();
                isDrawing = true;
                canvas.setPointerCapture(e.pointerId);
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top + editor.getScrollTop();
                // Initialize stroke points array
                currentStroke = {points: [{x, y, p: e.pressure}], bbox: null};
                ctx.beginPath();
                ctx.moveTo(x, y - editor.getScrollTop());
            } else if (mode === 'scroll') {
                e.preventDefault();
                isDrawing = true;
                canvas.setPointerCapture(e.pointerId);
                scrollStartY = e.clientY;
                scrollStartX = e.clientX;
                origScrollTop = editor.getScrollTop();
                origScrollLeft = editor.getScrollLeft();
            }
        });

        // Continue stroke or scroll on move
        canvas.addEventListener('pointermove', e => {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            if (mode === 'draw' && e.pointerType === 'pen') {
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top + editor.getScrollTop();
                // Record each point with its own pressure
                currentStroke.points.push({x, y, p: e.pressure});
                ctx.lineWidth = 2 * e.pressure;
                ctx.lineCap = 'round';
                ctx.lineTo(x, y - editor.getScrollTop());
                ctx.stroke();
            } else if (mode === 'scroll') {
                const dy = e.clientY - scrollStartY;
                const dx = e.clientX - scrollStartX;
                editor.setScrollTop(origScrollTop - dy);
                editor.setScrollLeft(origScrollLeft - dx);
                scheduleRedraw();
            }
        });

        // End stroke or scroll on up
        canvas.addEventListener('pointerup', e => {
            if (!isDrawing) return;
            if (mode === 'draw' && currentStroke) {
                currentStroke.bbox = computeBBox(currentStroke.points);
                strokes.push(currentStroke);
                currentStroke = null;
            }
            isDrawing = false;
            canvas.releasePointerCapture(e.pointerId);
        });

        canvas.addEventListener('pointercancel', e => {
            if (!isDrawing) return;
            if (mode === 'draw' && currentStroke) {
                currentStroke.bbox = computeBBox(currentStroke.points);
                strokes.push(currentStroke);
                currentStroke = null;
            }
            isDrawing = false;
            canvas.releasePointerCapture(e.pointerId);
        });

        // Redraw visible strokes only
        function redrawCanvas() {
            const rect = canvas.getBoundingClientRect();
            ctx.clearRect(0, 0, rect.width, rect.height);
            const viewTop = editor.getScrollTop();
            const viewBottom = viewTop + rect.height;
            ctx.save();
            ctx.translate(0, -viewTop);
            ctx.lineCap = 'round';

            for (const stroke of strokes) {
                const bb = stroke.bbox;
                if (!bb || bb.maxY < viewTop || bb.minY > viewBottom) continue;
                ctx.beginPath();
                stroke.points.forEach((pt, i) => {
                    if (i === 0) ctx.moveTo(pt.x, pt.y);
                    else {
                        ctx.lineWidth = 2 * pt.p;  // per-point pressure
                        ctx.lineTo(pt.x, pt.y);
                    }
                });
                ctx.stroke();
            }
            ctx.restore();
        }

        editor.onDidScrollChange(() => scheduleRedraw());
        scheduleRedraw();
    });
</script>
</body>
</html>
