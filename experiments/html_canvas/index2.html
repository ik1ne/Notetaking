<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Monaco Editor Stylus Drawing Demo</title>
    <script src="https://unpkg.com/monaco-editor@latest/min/vs/loader.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
        }

        #container {
            width: 800px;
            height: 600px;
            position: relative;
            border: 1px solid #ccc;
        }

        #editor {
            width: 100%;
            height: 100%;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none;
        }
    </style>
</head>
<body>
<div id="container">
    <div id="editor"></div>
    <canvas id="overlay"></canvas>
</div>
<script>
    // Configure Monaco loader
    require.config({paths: {'vs': 'https://unpkg.com/monaco-editor@latest/min/vs'}});
    require(['vs/editor/editor.main'], function () {
        // Create Monaco editor with 1000 lines of dummy code
        const editor = monaco.editor.create(document.getElementById('editor'), {
            value: Array.from({length: 1000}, (_, i) => '// Line ' + (i + 1)).join("\n"),
            language: 'javascript',
        });

        const container = document.getElementById('container');
        const canvas = document.getElementById('overlay');
        const ctx = canvas.getContext('2d');
        let strokes = [];
        let currentStroke = null;
        let drawing = false;
        let drawRequested = false;
        // Track scroll offsets
        let scrollTop = editor.getScrollTop();
        let scrollLeft = editor.getScrollLeft();

        // Resize canvas to match container size
        function resizeCanvas() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', () => {
            resizeCanvas();
            scheduleDraw();
        });

        // Schedule a redraw on the next animation frame
        function scheduleDraw() {
            if (!drawRequested) {
                drawRequested = true;
                requestAnimationFrame(() => {
                    drawRequested = false;
                    draw();
                });
            }
        }

        // Draw visible strokes
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(-scrollLeft, -scrollTop);
            ctx.strokeStyle = 'black';
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            const viewX1 = scrollLeft;
            const viewY1 = scrollTop;
            const viewX2 = scrollLeft + canvas.width;
            const viewY2 = scrollTop + canvas.height;
            // Draw completed strokes
            for (const stroke of strokes) {
                if (stroke.maxX < viewX1 || stroke.minX > viewX2 ||
                    stroke.maxY < viewY1 || stroke.minY > viewY2) {
                    continue;
                }
                ctx.lineWidth = stroke.width;
                ctx.stroke(stroke.path);
            }
            // Draw current stroke
            if (currentStroke) {
                const pts = currentStroke.points;
                if (pts.length > 0) {
                    ctx.lineWidth = currentStroke.width;
                    ctx.beginPath();
                    ctx.moveTo(pts[0].x, pts[0].y);
                    for (let i = 1; i < pts.length; i++) {
                        ctx.lineTo(pts[i].x, pts[i].y);
                    }
                    ctx.stroke();
                }
            }
            ctx.restore();
        }

        // Add a point to the current stroke and update bounding box
        function addPointToStroke(x, y, pressure) {
            currentStroke.points.push({x, y});
            currentStroke.totalPressure += pressure;
            if (x < currentStroke.minX) currentStroke.minX = x;
            if (x > currentStroke.maxX) currentStroke.maxX = x;
            if (y < currentStroke.minY) currentStroke.minY = y;
            if (y > currentStroke.maxY) currentStroke.maxY = y;
        }

        // Handle stylus pointer down
        canvas.addEventListener('pointerdown', (e) => {
            if (e.pointerType !== 'pen') return;
            drawing = true;
            canvas.setPointerCapture(e.pointerId);
            currentStroke = {
                points: [],
                minX: Infinity, minY: Infinity,
                maxX: -Infinity, maxY: -Infinity,
                totalPressure: 0,
                width: 1
            };
            const x = e.offsetX + scrollLeft;
            const y = e.offsetY + scrollTop;
            addPointToStroke(x, y, e.pressure);
            scheduleDraw();
        });

        // Handle stylus pointer move
        canvas.addEventListener('pointermove', (e) => {
            if (!drawing || e.pointerType !== 'pen') return;
            const x = e.offsetX + scrollLeft;
            const y = e.offsetY + scrollTop;
            addPointToStroke(x, y, e.pressure);
            scheduleDraw();
        });

        // End the stroke on pointer up or cancel
        function endStroke(e) {
            if (!drawing || e.pointerType !== 'pen') return;
            drawing = false;
            canvas.releasePointerCapture(e.pointerId);
            const x = e.offsetX + scrollLeft;
            const y = e.offsetY + scrollTop;
            addPointToStroke(x, y, e.pressure);
            // Calculate stroke width from average pressure
            const avgPressure = currentStroke.totalPressure / currentStroke.points.length;
            currentStroke.width = Math.max(1, avgPressure * 10);
            // Build Path2D for the stroke
            const path = new Path2D();
            const pts = currentStroke.points;
            if (pts.length > 0) {
                path.moveTo(pts[0].x, pts[0].y);
                for (let i = 1; i < pts.length; i++) {
                    path.lineTo(pts[i].x, pts[i].y);
                }
            }
            currentStroke.path = path;
            strokes.push(currentStroke);
            currentStroke = null;
            scheduleDraw();
        }

        canvas.addEventListener('pointerup', endStroke);
        canvas.addEventListener('pointercancel', endStroke);

        // Redraw when the editor is scrolled
        editor.onDidScrollChange((e) => {
            scrollTop = e.scrollTop;
            scrollLeft = e.scrollLeft;
            scheduleDraw();
        });

        // Initial draw
        draw();
    });
</script>
</body>
</html>
