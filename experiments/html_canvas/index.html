<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Monaco + Canvas Demo (Optimized)</title>
    <style>
        html, body, #wrapper, #editor-container {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        #wrapper {
            position: relative;
        }

        #editor-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            touch-action: none;
            z-index: 10;
        }
    </style>
</head>
<body>
<div id="wrapper">
    <div id="editor-container"></div>
    <canvas id="overlay"></canvas>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script>
<script>
    let strokes = [];
    let offscreen, offctx;

    require.config({paths: {'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.38.0/min/vs'}});
    require(['vs/editor/editor.main'], function () {
        // Populate editor content
        const lines = ['function longFunction() {'];
        for (let i = 0; i < 100; i++) lines.push(`  console.log("line ${i}");`);
        lines.push('}', '', '// filler below');
        for (let i = 0; i < 50; i++) lines.push(`// extra ${i}`);
        lines.push('', 'function hello() {', '  console.log("Hello, world!");', '}');

        window.editor = monaco.editor.create(
            document.getElementById('editor-container'), {
                value: lines.join('\n'), language: 'javascript', theme: 'vs-light', automaticLayout: true
            }
        );

        // Prepare offscreen canvas matching document size
        const docWidth = editor.getScrollWidth();
        const docHeight = editor.getScrollHeight();
        offscreen = document.createElement('canvas');
        offscreen.width = docWidth;
        offscreen.height = docHeight;
        offctx = offscreen.getContext('2d');
        offctx.lineCap = 'round';
        offctx.lineJoin = 'round';

        // Prepopulate 1000 random strokes in document coords and draw once offscreen
        for (let i = 0; i < 1000; i++) {
            const stroke = [];
            const baseX = Math.random() * docWidth;
            const baseY = Math.random() * docHeight;
            let x = baseX, y = baseY;
            for (let j = 0; j < 10; j++) {
                const p = {x, y, pressure: Math.random()};
                stroke.push(p);
                // draw segment on offscreen
                if (j > 0) {
                    const prev = stroke[j - 1];
                    offctx.lineWidth = 2 + p.pressure * 8;
                    offctx.beginPath();
                    offctx.moveTo(prev.x, prev.y);
                    offctx.lineTo(p.x, p.y);
                    offctx.stroke();
                }
                x += (Math.random() - 0.5) * 100;
                y += (Math.random() - 0.5) * 40;
            }
            strokes.push(stroke);
        }

        // Hook scroll to redraw viewport from offscreen
        editor.onDidScrollChange(render);
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        setMode('pass');
    });
</script>

<script>
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    let mode = 'pass', drawing = false, currentStroke = null, lastPos = {x: 0, y: 0};

    function resizeCanvas() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        render();
    }

    function render() {
        const sl = editor.getScrollLeft();
        const st = editor.getScrollTop();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // draw only the visible region from offscreen
        ctx.drawImage(
            offscreen,        // source
            sl, st,           // source x,y
            canvas.width,     // source w
            canvas.height,    // source h
            0, 0,             // dest x,y
            canvas.width,     // dest w
            canvas.height     // dest h
        );
    }

    function setMode(m) {
        mode = m;
        if (mode === 'pass') {
            canvas.style.pointerEvents = 'none';
            canvas.style.touchAction = 'auto';
        } else {
            canvas.style.pointerEvents = 'auto';
            canvas.style.touchAction = 'none';
        }
    }

    document.addEventListener('keydown', e => {
        if (!e.ctrlKey && !e.altKey && e.code.startsWith('Digit')) {
            if (e.code === 'Digit1') {
                setMode('pass');
                e.preventDefault();
            }
            if (e.code === 'Digit2') {
                setMode('draw');
                e.preventDefault();
            }
            if (e.code === 'Digit3') {
                setMode('scroll');
                e.preventDefault();
            }
        }
    });

    canvas.addEventListener('pointerdown', e => {
        const sl = editor.getScrollLeft(), st = editor.getScrollTop();
        if (mode === 'draw' && e.pointerType === 'pen') {
            currentStroke = [];
            strokes.push(currentStroke);
            const p = {x: e.clientX + sl, y: e.clientY + st, pressure: e.pressure};
            currentStroke.push(p);
            drawing = true;
            canvas.setPointerCapture(e.pointerId);
            e.preventDefault();
        } else if ((mode === 'draw' && e.pointerType === 'mouse') ||
            (mode === 'scroll' && (e.pointerType === 'touch' || e.button === 1))) {
            drawing = true;
            lastPos = {x: e.clientX, y: e.clientY};
            canvas.setPointerCapture(e.pointerId);
            e.preventDefault();
        }
    });

    canvas.addEventListener('pointermove', e => {
        if (!drawing) return;
        const sl = editor.getScrollLeft(), st = editor.getScrollTop();
        if (mode === 'draw' && e.pointerType === 'pen') {
            const p = {x: e.clientX + sl, y: e.clientY + st, pressure: e.pressure};
            currentStroke.push(p);
            // draw new segment on offscreen and viewport
            const prev = currentStroke[currentStroke.length - 2];
            offctx.lineWidth = 2 + p.pressure * 8;
            offctx.beginPath();
            offctx.moveTo(prev.x, prev.y);
            offctx.lineTo(p.x, p.y);
            offctx.stroke();
            render();
            e.preventDefault();
        } else if (mode === 'draw' && e.pointerType === 'mouse') {
            const dx = lastPos.x - e.clientX, dy = lastPos.y - e.clientY;
            editor.setScrollTop(editor.getScrollTop() + dy);
            editor.setScrollLeft(editor.getScrollLeft() + dx);
            lastPos = {x: e.clientX, y: e.clientY};
            e.preventDefault();
        } else if (mode === 'scroll') {
            const dx = lastPos.x - e.clientX, dy = lastPos.y - e.clientY;
            editor.setScrollTop(editor.getScrollTop() + dy);
            editor.setScrollLeft(editor.getScrollLeft() + dx);
            lastPos = {x: e.clientX, y: e.clientY};
            e.preventDefault();
        }
    });

    canvas.addEventListener('pointerup', e => {
        drawing = false;
        canvas.releasePointerCapture(e.pointerId);
    });
    canvas.addEventListener('pointercancel', e => {
        drawing = false;
        canvas.releasePointerCapture(e.pointerId);
    });
</script>
</body>
</html>
